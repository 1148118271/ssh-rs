
mod tests {
    use aes::Aes128Ctr;
    use aes::cipher::{NewCipher, StreamCipher, StreamCipherSeek};
    use aes::cipher::generic_array::GenericArray;

    #[test]
    fn f() {
        let ckey = [32_u8, 59, 160, 246, 139, 196, 208, 4, 112, 195, 76, 74, 254, 173, 172, 57];
        let civ  = [132_u8, 174, 184, 176, 168, 56, 129, 240, 56, 234, 129, 183, 8, 244, 32, 169];


        let mut buf = vec![0_u8, 0, 0, 92, 31, 50, 0, 0, 0, 4, 114, 111, 111, 116, 0, 0, 0, 14, 115, 115, 104, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 0, 8, 112, 97, 115, 115, 119, 111, 114, 100, 0, 0, 0, 0, 16, 71, 97, 111, 120, 105, 97, 110, 103, 107, 97, 110, 103, 64, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let mut buf_1 = vec![0_u8, 0, 0, 92, 31, 50, 0, 0, 0, 4, 114, 111, 111, 116, 0, 0, 0, 14, 115, 115, 104, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 0, 8, 112, 97, 115, 115, 119, 111, 114, 100, 0, 0, 0, 0, 16, 71, 97, 111, 120, 105, 97, 110, 103, 107, 97, 110, 103, 64, 49, 50, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        let buf1 = [128_u8, 65, 115, 31, 142, 184, 153, 56, 41, 44, 69, 81, 33, 224, 22, 232, 212, 0, 23, 34, 104, 91, 193, 223, 60, 178, 115, 219, 134, 50, 35, 213, 201, 199, 227, 141, 179, 6, 164, 124, 52, 227, 48, 190, 130, 210, 112, 25, 89, 175, 211, 182, 170, 109, 18, 154, 51, 235, 20, 72, 36, 3, 31, 164, 23, 163, 186, 77, 213, 220, 15, 195, 222, 95, 64, 49, 134, 236, 42, 83, 149, 94, 68, 84, 187, 220, 159, 168, 181, 241, 49, 39, 83, 212, 31, 14];
        let buf2 = [128_u8, 65, 115, 31, 142, 184, 153, 56, 41, 44, 69, 81, 33, 224, 22, 232, 212, 0, 23, 34, 104, 91, 193, 223, 60, 178, 115, 219, 134, 50, 35, 213, 201, 199, 227, 141, 179, 6, 164, 124, 52, 227, 48, 190, 130, 210, 112, 25, 89, 175, 211, 182, 170, 109, 18, 154, 51, 235, 20, 72, 36, 3, 31, 164, 23, 163, 186, 77, 213, 220, 15, 195, 222, 95, 64, 49, 134, 236, 42, 83, 149, 94, 68, 84, 187, 220, 159, 168, 181, 241, 49, 39, 83, 212, 31, 14];

        let slice = GenericArray::from(ckey);
        let n = GenericArray::from(civ);
        let mut e = Aes128Ctr::new_from_slices(&slice, &n).unwrap();
        let mut d = Aes128Ctr::new_from_slices(&slice, &n).unwrap();



        println!("加密前 => {:?}", buf);
        e.apply_keystream(&mut buf);
        //e.seek(0);
        println!("加密后 => {:?}", buf);
        d.apply_keystream(&mut buf);
        //d.seek(0);
        println!("解密后 => {:?}", buf);

        println!("加密前 => {:?}", buf);
        e.apply_keystream(&mut buf);
        println!("加密后 => {:?}", buf);
        d.apply_keystream(&mut buf);
        println!("解密后 => {:?}", buf);
    }


    #[test]
    fn test2() {
        let bsize = 64;
        let data_len = 556;


        let mut padding_len = 8 - (data_len + 1) % 8;
        if padding_len < 4 { padding_len += 8 }

        //
        // let len = data_len + 5;
        // let mut pad = 4;
        // loop {
        //     if (len + pad) % bsize == 0 {
        //         break;
        //     }
        //     pad = pad + 1;
        // }


        println!("{}",  padding_len + 1 + 5 + 3)

    }
}



