# ssh-rs ✨

[English](https://github.com/1148118271/ssh-rs/blob/main/README.md)  |  [简体中文](https://github.com/1148118271/ssh-rs/blob/main/README_ZH.md)

Rust implementation of ssh2.0 client.

If you encounter any problems in use, welcome [issues](https://github.com/1148118271/ssh-rs/issues)
or [PR](https://github.com/1148118271/ssh-rs/pulls) .

## Connection method：

### 1. Password:

```rust
fn main() {
    use ssh_rs::ssh;
    let mut session = ssh::create_session()
        .username("username")
        .password("password")
        .build();
    session.connect("ip:port").unwrap();
}
```

### 2. Public key:

#### Currently, only `RSA-PKCS#1-PEM` type encrypted files with the encryption format `-----BEGIN RSA PRIVATE KEY-----` are supported.

#### 1. Use key file path：

```rust
fn main() {
    // pem format key path -> /xxx/xxx/id_rsa
    // the content of the keyfile shall begin with
    //      -----BEGIN RSA PRIVATE KEY-----
    // and end with
    //       -----END RSA PRIVATE KEY-----
    // simply generated by `ssh-keygen -t rsa -m PEM -b 4096`
    // KeyPairType::SshRsa -> Rsa type algorithm, currently only supports rsa.
    use ssh_rs::ssh;
    let mut session = ssh::create_session()
        .username("username")
        .private_key_path("/path/to/rsa")
        .build();
    session.connect("ip:port").unwrap();
}    
```

#### 2. Use key string：

```rust
fn main() {
    // pem format key string:
    //      -----BEGIN RSA PRIVATE KEY-----
    //          xxxxxxxxxxxxxxxxxxxxx
    //      -----END RSA PRIVATE KEY-----
    // KeyPairType::SshRsa -> Rsa type algorithm, currently only supports rsa.
    use ssh_rs::ssh;
    let mut session = ssh::create_session()
        .username("username")
        .private_key("rsa_string")
        .build();
    session.connect("ip:port").unwrap();
```

#### 3. Use them together

* According to the implementation of OpenSSH, it will try public key first and fallback to password. So both of them can be provided.

```Rust
use ssh_rs::ssh;
let mut session = ssh::create_session()
    .username("username")
    .password("password")
    .private_key_path("/path/to/rsa")
    .build();
session.connect("ip:port").unwrap();
```

## Enable global logging：

```no_run
use ssh_rs::ssh;
// is_enable_log Whether to enable global logging
// The default is false(Do not enable)
// Can be set as true (enable)
ssh::is_enable_log(true);
```

## Enable global logging：

```rust
fn main() {
    // is_enable_log Whether to enable global logging
    // The default is false(Do not enable)
    // Can be set as true (enable)
    use ssh_rs::ssh;
    ssh::is_enable_log(true);
}
```

## Set timeout：

```rust

fn main() {
    use ssh_rs::ssh;
    // set_timeout
    // The unit is seconds
    // The default timeout is 30 seconds
    let mut session = ssh::create_session()
        .timeout(15)
        .username("username")
        .password("password")
        .build();
    session.connect("ip:port").unwrap();
}
```

## How to use：

### Currently only supports exec shell scp these three functions.

### 1. exec

```rust
use ssh_rs::ssh;

fn main() {
    ssh::is_enable_log(true);

    let mut session = ssh::create_session()
        .username("username")
        .password("password")
        .private_key_path("/path/to/rsa")
        .build();
    session.connect("ip:port").unwrap();
    // Usage 1
    let exec = session.open_exec().unwrap();
    let vec: Vec<u8> = exec.send_command("ls -all").unwrap();
    println!("{}", String::from_utf8(vec).unwrap());
    // Usage 2
    let channel = session.open_channel().unwrap();
    let exec = channel.open_exec().unwrap();
    let vec: Vec<u8> = exec.send_command("ls -all").unwrap();
    println!("{}", String::from_utf8(vec).unwrap());
    // Close session.
    session.close();
}
```

### 2. shell

```rust
use ssh_rs::{ssh, ChannelShell};
use std::thread::sleep;
use std::time::Duration;

fn main() {
    let mut session = ssh::create_session()
        .username("username")
        .password("password")
        .build();
    session.connect("ip:port").unwrap();
    // Usage 1
    let mut shell = session.open_shell().unwrap();
    run_shell(&mut shell);
    // Usage 2
    let channel = session.open_channel().unwrap();
    let mut shell = channel.open_shell().unwrap();
    run_shell(&mut shell);
    // Close channel.
    shell.close().unwrap();
    // Close session.
    session.close();
}

fn run_shell(shell: &mut ChannelShell<std::net::TcpStream>) {
    sleep(Duration::from_millis(500));
    let vec = shell.read().unwrap();
    println!("{}", String::from_utf8(vec).unwrap());

    shell.write(b"ls -all\n").unwrap();

    sleep(Duration::from_millis(500));

    let vec = shell.read().unwrap();
    println!("{}", String::from_utf8(vec).unwrap());
}
```

### 3. scp

```rust
use ssh_rs::ssh;

fn main() {
    let mut session = ssh::create_session()
        .username("username")
        .password("password")
        .build();
    session.connect("ip:port").unwrap();

    // Usage 1
    let scp = session.open_scp().unwrap();
    scp.upload("local path", "remote path").unwrap();
   
    let scp = session.open_scp().unwrap();
    scp.download("local path", "remote path").unwrap();

    // Usage 2
    let channel = session.open_channel().unwrap();
    let scp = channel.open_scp().unwrap();
    scp.upload("local path", "remote path").unwrap();
  
    let channel = session.open_channel().unwrap();
    let scp = channel.open_scp().unwrap();
    scp.download("local path", "remote path").unwrap();

    session.close().unwrap();
}

```

## bio:

```rust
use ssh_rs::ssh;
use std::net::{TcpStream, ToSocketAddrs};

fn main() {
    let bio = MyProxy::new("ip:port");
    let mut session = ssh::create_session()
        .username("username")
        .password("password")
        .build();
    session.connect_bio(bio).unwrap();
    // Usage 1
    let exec = session.open_exec().unwrap();
    let vec: Vec<u8> = exec.send_command("ls -all").unwrap();
    println!("{}", String::from_utf8(vec).unwrap());
    // Usage 2
    let channel = session.open_channel().unwrap();
    let exec = channel.open_exec().unwrap();
    let vec: Vec<u8> = exec.send_command("ls -all").unwrap();
    println!("{}", String::from_utf8(vec).unwrap());
    // Close session.
    session.close();
}

// Use a real ssh server since I don't wanna implement a ssh-server in the example codes
struct MyProxy {
    server: TcpStream,
}

impl MyProxy {
    fn new<A>(addr: A) -> Self
    where
        A: ToSocketAddrs,
    {
        Self {
            server: TcpStream::connect(addr).unwrap(),
        }
    }
}

impl std::io::Read for MyProxy {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        self.server.read(buf)
    }
}

impl std::io::Write for MyProxy {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        self.server.write(buf)
    }

    fn flush(&mut self) -> std::io::Result<()> {
        self.server.flush()
    }
}

```

## customized_algortihms

```Rust
use ssh_rs::algorithm;
use ssh_rs::ssh;

fn main() {
    ssh::is_enable_log(true);

    let mut session = ssh::create_session_without_default()
        .username("username")
        .private_key_path("/path/to/rsa")
        .password("password")
        .add_kex_algorithms(algorithm::Kex::Curve25519Sha256)
        .add_pubkey_algorithms(algorithm::PubKey::SshRsa) // must enable the feature "dangerous-algorithms"
        .add_enc_algorithms(algorithm::Enc::Chacha20Poly1305Openssh)
        .add_compress_algorithms(algorithm::Compress::None)
        .add_mac_algortihms(algorithm::Mac::HmacSha1)
        .build();
    session.connect("ip:port").unwrap();
    // Usage 1
    let exec = session.open_exec().unwrap();
    let vec: Vec<u8> = exec.send_command("ls -all").unwrap();
    println!("{}", String::from_utf8(vec).unwrap());
    // Close session.
    session.close();
}
```

## Algorithm support：

### 1. Kex algorithms

* `curve25519-sha256`
* `ecdh-sha2-nistp256`

### 2. Server host key algorithms

* `ssh-ed25519` (coming soon)
* `rsa-sha2-256`
* `rsa-sha` (behind feature "dangerous-rsa-sha1")

### 3. Encryption algorithms (client to server)

* `chacha20-poly1305@openssh.com`
* `aes128-ctr`

### 4. Encryption algorithms (server to client)

* `chacha20-poly1305@openssh.com`
* `aes128-ctr`

### 5. Mac algorithms (client to server)

* `hmac-sha1`

### 6. Mac algorithms (server to client)

* `hmac-sha1`

### 7. Compression algorithms (client to server)

* `none`

### 8. Compression algorithms (server to client)

* `none`

---

### ☃️ Additional algorithms will continue to be added.
